/**
 * @file Random.h
 * @brief 随机数生成器实现
 * @author 殉道者 (wcjbyjx@gmail.com)
 * @version 0.0.1
 * @date 2021-01-26
 * @copyright Copyright © 2014-2021 weichijunbo.
 * @details     随机数生成器的实现，实现了绝大部分的随机数生成算法包括冯·诺伊曼平方取中法及其改良算法、
 * 线性同余发生器、梅森旋转演算法，FSR发生器、组合发生器（因为效率原因，未作实现）。由于需要生成符合常见分布的随机数，
 * 故采用随机数生成算法生成符合均匀分布(即一个周期内所有数据出现是等概率)的随机数，再利用均匀分布的随机数生成符合其它分布的随
 * 机数。
 * @see [随机数的前世今生](https://www.nkdacs.com/share/Random%20number/Random%20number/#6)
 * @see [漫谈正态分布的生成](https://cosx.org/2015/06/generating-normal-distr-variates)
 * *********************************************************************************
 * @par ChangeLog:
 * <table>
 * <tr><th>Date       <th>Version <th>Author  <th>Description
 * <tr><td>2021-01-26 <td>0.0.1    <td>殉道者     <td>内容
 * </table>
 * *********************************************************************************
 */
#pragma once

#include <time.h>
#include "tools.h"
#include <iostream> 
#include <stdint.h>
#include <stdlib.h>
const double __TWO32__ = 4294967296.0; ///2^32
const unsigned long int __TWO31__ = 2147483647; ///2^31

/**
 * @brief 根据系统时间获取随机数种子，作为随机数生成算法中的初值
 * @param  _seed            初始化随机数种子，0表示使用时间种子，其余整数则直接使用314159+_seed作为随机数种子
 */
unsigned long _seed_(int _seed);

/**
 * @brief 冯·诺依曼平方取中法用于生成符合均匀分布的随机序列,不建议使用
 * @details     基本思想为：将数列中的第a(i)项（假设其有 m 位）平方，
 * 取得到的2m位数（若不足 2m 位，在最高位前补 0）中间部分的m位数字
 * 10^{[m/2]+1})至10^{[m/2]+m}的数作为a(i)的下一项 a(i+1)，由此产
 * 生一个伪随机数数列。
 * @section 算法描述
 * -# 选择一个m位数N(i)作为种子；
 * -# 计算N(i)的平方
 * @section C++数据类型
 *  数据类                   字节大小	        数值范围
 *  short int                2 字节	     -32768 〜+32767 (-2^15~2^15-1)
 *  unsigned short int       2 字节	     0 〜+65535 (0~2^16-1)
 *  int                      4 字节	     -2147483648 〜+2147483647 (-2^32-1~2^32-1)
 *  unsigned int 	         4 字节	     0 〜4294967295 (0~2^32-1)
 *  long int                 4 字节	     -2147 483 648 〜+2 147 483 647  (-2^31~2^31-1)
 *  unsigned long int	     4 字节 	 0 〜4294967295 (0~2^32-1)
 *  long long int 	         8 字节	     -9223372036854775808~9223372036854775807 (-2^63~2^63-1)
 *  unsigned long long int   8 字节	     18446744073709551615 (0~2^64 - 1)
 * @return float* @c 
 */
unsigned long int _MiddleSquare_(int seed);

/**
 * @brief 基于Wely等分布定理的平方取中法实现
 * @see [Wely序列](https://www.wikiwand.com/en/Weyl_sequence)
 * @attention &emsp;&emsp;需要说明的是，在计算机中，Wely序列的整数形式通常用于生成离散的
 * 均匀分布，而不是连续的分布。因为无法使用计算机表示无理数，所以使用有理数来进行近似，而所
 * 有有理数都可以表示为分数即两个整数的比率。因此选择整数k，它相对于整数模数m为质数。在m为2
 * 的幂的常见情况下，这等于要求k为奇数。此时，序列0,k,2k,3k,...是模m的均匀分布。即每个项的
 * 余数的序列在被m除时将均匀地分布在间隔[0，m）中
 * @return T @c 
 */
template<class T>
inline static T _WelySquare_() 
{
    uint64_t x = 0, w = 0, s = 0xb5ad4eceda1ce2a9;
    x *= x; 
    x += (w += s); 
    return x = (x>>32) | (x<<32);
}

/**************************************************************************\
*                                                                          *
*  Four round counter-based middle square                                  *
*                                                                          *
*  squares(ctr,key) - returns a 32-bit unsigned int [0,0xffffffff]         *
*                                                                          *
*  The parameters are patterned after Philox parameters. The first is      *
*  the counter.  This is an arbitrary 64-bit unsigned integer.  The        *
*  second is the key.  The key should be an entry from the keys.h file.    *
*  The keys.h file contains keys that have been created with different     *
*  hexadecimal digits. This assures sufficient change in the ctr*key       *
*  computation.                                                            *
*                                                                          *
*  This generator would be used in a similar way as Philox.  One would     *
*  increment a counter and then call the RNG to generate a random number.  *
*                                                                          *
*  Four rounds of squaring are performed and the result is returned.       *
*  For the first three rounds, the result is rotated right 32 bits.        *
*  This places the random data in the best position for the next round.    *
*  y = ctr*key or z = (ctr+1)*key is added on each round.  For keys        *
*  generated by the key utility, either ctr*key or (ctr+1)*key will        *
*  have non-zero digits.  This improves randomization and also provides    *
*  for a uniform output.                                                   *
*                                                                          *
*  Note:  The squares RNG was based on ideas derived from Middle Square    *
*  Weyl Sequence RNG.  One of the ideas was to obtain uniformity by adding *
*  the Weyl sequence after squaring.  Richard P. Brent (creator of the     *
*  xorgens RNG) suggested this method.  It turns out that adding ctr*key   *
*  is equivalent.  Brent's idea provides the basis for uniformity in this  *
*  generator.                                                              *                                            *
\**************************************************************************/
/**
 * @brief  基于Wely序列的四轮平方取中随机数生成器的实现，是满周期的（即生成的随机数在周期内不重复） 
 * @param  ctr              生成的随机数的序号，保证每次生成的随机数是不同的
 * @param  key              有keys.h存储的密钥，每个密钥可生成2^32个不重复的随机数，
 * @see 2020-11-23 [Squares: A Fast Counter-Based RNG] (https://arxiv.org/abs/2004.06278v3)
 * @attention &emsp;&emsp;2020-05-19 论文[https://arxiv.org/abs/1704.00358v5](https://arxiv.org/abs/1704.00358v5) 
 * 提出了一种基于Wely序列的平方取中改良算法，克服了平方取中的"Zero mechanism"等问题。
 * @return uint32_t @c 
 */
template<class T>
inline static T _FourRoundWelySquares_(uint64_t ctr) 
{
    uint64_t key[] = 
    {
        #include "keys.h"
    };
    uint64_t x, y, z;
    y = x = ctr * key[0]; z = y + key[0];
   
    x = x*x + y; x = (x>>32) | (x<<32);       /* round 1 */

    x = x*x + z; x = (x>>32) | (x<<32);       /* round 2 */

    x = x*x + y; x = (x>>32) | (x<<32);       /* round 3 */

    return ((x*x + z) >> 32) / __TWO32__ ;                   /* round 4 */
}

/**
 * @brief   Kobayashi混合同余发生器的实现，该生成器为满周期 2^31 的混合同余发生器，其周期较长，
 * 统计性质比较好，迭代式如下：
 * x(n) = (314159269*x(n-1)+453806245) mod 2^31
 * @see https://www.nkdacs.com/share/Random%20number/Random%20number/#6
 * @attention &emsp;&emsp;同余发生器的原理是不断进行同余运算来迭代生成满足均匀分布的随机数，
 * 其生成的随机数统计性质较好，但是由于其生成机制的缺陷，导致随机数相邻项之前存在强依赖，本实
 * 现只用于学习使用，不做实际使用。其它类型的线性同余生成器如乘同余和素数模乘同余只是加强了生
 * 成算法的约束，在此不做实现。
 * @tparam T 
 * @param  seed           随机数种子
 * @return T @c 
 */
template<class T>
inline static T _LCG_(unsigned long seed)
{
    unsigned long x_n = (314159269 * seed +453806245) % __TWO31__;
    return (T) x_n  / __TWO31__;
}

static unsigned int x = 123456789, y = 362436069, z = 521288629;

/**
 * @brief 基于线性反馈移位寄存器生成随机数
 * https://www.wikiwand.com/en/Xorshift
 * @note Xorshift 随机数生成器是 George Marsaglia 发明的一类伪随机数生成器。
 * 它们通过和自己逻辑移位后的数进行异或操作来生成序列中的下一个数。这在现代计算
 * 机体系结构非常快。它们是线性反馈移位寄存器的一个子类，其简单的实现使它们速度
 * 更快且使用更少的空间。然而，必须仔细选择合适参数以达到长周期。
 * @return ** unsigned int 
 */
unsigned int random_gen_fast(void)
{
    unsigned int t;
    x ^= x << 16;
    x ^= x >> 5;
    x ^= x << 1;

    t = x;
    x = y;
    y = z;
    z = t ^ x ^ y;

    return z;
}

float random_float_fast()
{
    return ((float)random_gen_fast() / (float)UINT_MAX);
}

int rand_int_fast(int min, int max)
{
    if (max < min) {
        int s = min;
        min = max;
        max = s;
    }
    int r = (random_gen_fast() % (max - min + 1)) + min;
    return r;
}

unsigned int random_gen()
{
    unsigned int rnd = 0;
#ifdef WIN32
   // rand_s(&rnd);
#else   // WIN32
    rnd = rand();
#if (RAND_MAX < 65536)
        rnd = rand()*(RAND_MAX + 1) + rnd;
#endif  //(RAND_MAX < 65536)
#endif  // WIN32
    return rnd;
}

float random_float()
{
    unsigned int rnd = 0;
#ifdef WIN32
    //rand_s(&rnd);
    return ((float)rnd / (float)UINT_MAX);
#else   // WIN32
    rnd = rand();
#if (RAND_MAX < 65536)
    rnd = rand()*(RAND_MAX + 1) + rnd;
    return((float)rnd / (float)(RAND_MAX*RAND_MAX));
#endif  //(RAND_MAX < 65536)
    return ((float)rnd / (float)RAND_MAX);

#endif  // WIN32
}

float rand_uniform_strong(float min, float max)
{
    if (max < min) {
        float swap = min;
        min = max;
        max = swap;
    }
    return (random_float() * (max - min)) + min;
}

float rand_precalc_random(float min, float max, float random_part)
{
    if (max < min) {
        float swap = min;
        min = max;
        max = swap;
    }
    return (random_part * (max - min)) + min;
}

#define RS_SCALE (1.0 / (1.0 + RAND_MAX))

double double_rand(void)
{
    double d;
    do {
        d = (((rand() * RS_SCALE) + rand()) * RS_SCALE + rand()) * RS_SCALE;
    } while (d >= 1); // Round off
    return d;
}

unsigned int uint_rand(unsigned int less_than)
{
    return (unsigned int)((less_than)* double_rand());
}
