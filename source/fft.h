#pragma once


/**
 * @brief 实现码位倒位序算法，雷德（Rader）算法。
 *     自然序排列的二进制数，其下面一个数总比上面的数大1，而倒序二进制数的下面一个数
 * 是上面一个数在最高位加1并由高位向低位仅为而得到的。 若已知某数的倒序数是J，求
 * 下一个倒序数，应先判断J的最高位是否为0，与k=N/2进行比较即可得到结果。如果k>J，
 * 说明最高位为0，应把其变成1，即J+N/2，这样就得到倒序数了。如果J<=k，即J的最高
 * 位为1，将最高位化为0，即J-N/2，再判断次高位；与k=N/4进行比较，若为0，将其变
 * 位1，即J+N/4，即得到倒序数，如果次高位为1，将其化为0，再判断下一位......
 * 即从高位到低位依次判断其是否为1，为1将其变位0，若这一位为0，将其变位1，即可得到
 * 倒序数。若倒序数小于顺序数，进行换位，否则不变，防治重复交换，变回原数。
 * 
 */
void Rader(unsigned int* array,int _size)
{
    int i,j,k;
    int temp;
    j = 0;

    for(i = 0; i < _size-1; i ++)
    {
        if(i < j)
        {
            temp = array[i];
            array[i] = array[j];
            array[j] = temp;
        }

        k = _size >> 1;

        while( k <= j)
        {
            j = j - k;
            k >>= 1;
        }

        j = j + k;
    }

}