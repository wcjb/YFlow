#pragma once


/**
 * @brief 实现码位倒位序算法，雷德（Rader）算法。
 *     自然序排列的二进制数，其下面一个数总比上面的数大1，而倒序二进制数的下面一个数
 * 是上面一个数在最高位加1并由高位向低位仅为而得到的。 若已知某数的倒序数是J，求
 * 下一个倒序数，应先判断J的最高位是否为0，与k=N/2进行比较即可得到结果。如果k>J，
 * 说明最高位为0，应把其变成1，即J+N/2，这样就得到倒序数了。如果J<=k，即J的最高
 * 位为1，将最高位化为0，即J-N/2，再判断次高位；与k=N/4进行比较，若为0，将其变
 * 位1，即J+N/4，即得到倒序数，如果次高位为1，将其化为0，再判断下一位......
 * 即从高位到低位依次判断其是否为1，为1将其变位0，若这一位为0，将其变位1，即可得到
 * 倒序数。若倒序数小于顺序数，进行换位，否则不变，防治重复交换，变回原数。
 * 
 */
void Rader(unsigned int* array,int _size)
{
    int i,j,k;
    int temp;
    j = 0;

    for(i = 0; i < _size-1; i ++)
    {
        if(i < j)
        {
            temp = array[i];
            array[i] = array[j];
            array[j] = temp;
        }

        k = _size >> 1;

        while( k <= j)
        {
            j = j - k;
            k >>= 1;
        }

        j = j + k;
    }

}
/**
 * @brief FFT码位倒序算法（rader 算法）讨论N = 8 的情形，如下表
 * --------------------------------------------------------------------------------
 * |                                      N = 8                                   |
 * --------------------------------------------------------------------------------
 * |        顺序排列        二进制码                 倒码（从0开始）       倒码排列   |
 * ---------------------------------------------------------------------------------
 * |           0              000                        000                 0     |
 * ---------------------------------------------------------------------------------
 * |           1              001                        100                 4     |
 * ---------------------------------------------------------------------------------
 * |           2              010                        011                 2     |
 * ---------------------------------------------------------------------------------
 * |           3              011                        110                 6     |
 * ---------------------------------------------------------------------------------
 * |           4              100                        001                 1     |
 * ---------------------------------------------------------------------------------
 * |           5              101                        101                 5     |
 * ---------------------------------------------------------------------------------
 * |           6              110                        011                 3     |
 * ---------------------------------------------------------------------------------
 * |           7              111                        111                 7     |
 * ---------------------------------------------------------------------------------
 *    由上表可知，按自然顺序排列的二进制数，其下一个数总比当前数大1，即下一个数是当前数在最低位
 * 加1并向高位进位而得到。而倒位序二进制的下一个数是当前数在其二进制形式的最高位加1并由高位向低
 * 位进位得到。
 *    基于上述规律，若已知某个倒位序J(0为已知)，求下一个倒位序数：
 *    首先判断J的最高位是否为0，测试可直接与K = N / 2比较得到，因为 N / 2的二进制形式一般都是如
 * 下形式:100...。
 *    1.if K > J ,则J的最高位为0，此时只需把最高位变为1（J+K）,则得到下一个倒序数J+K，算法结束；
 *    2.if K <= J,则J的最高位为1，此时先将最高位变为0（J-K）,计算K >>= 1,再进行判断次高位，重复
 *      1，2步骤,直到K <= 0。
 * @param source 需要计算倒位序数的顺序数
 * @param size    N
 * @return * void 
 */
void rader(unsigned int source,int size)
{
    // 已知0的倒序数
    int next = 0;     // 下一个倒序数
    int k = size >> 1;
    while(k > 0)
    {
        if (k > source)    // if k > source,则说明source的最高位为0
        {
            next = source + k;  // 下一个倒序数就是将source的最高位变为1（+k）
            break;
        }
        else // k << source,说明最高位为1
        {
            source -= k;     // 先将source的最高为变成0（-k）
            k >>= 1;
        }
    }
    return next;
}
template <typename T>
static void array_rader(T& array, int size)
{
    if (array == nullptr || size <=0)
    {
        return;
    }
    for (int i = 1; i < size ;i++) 
    {
        *(array + i) = rader(*(array + i-1),size);
    }
}
void reverse_order(unsigned int* array,int _size,int M)
{
    auto N = _size;
    int I,J;

    for(I=0;I<N;I++)   //根据规律四，需要对数组全部元素执行码间倒序
    {  
        /*获取下标I的反序J的数值*/ 
        J=0;
        for(k=0;k<(M/2+0.5);k++)     //k表示操作
        {
            /*反序操作*/
            m=1;//m是最低位为1的二进制数
            n=(unsigned int)pow(2,M-1);//n是第M位为1的二进制数
            m <<= k; //对m左移k位
            n>>= k; //对n右移k位
            F0=I & n;//I与n按位与提取出前半部分第k位
            F1=I & m;//I与m按位与提取出F0对应的后半部分的低位
            if(F0) J=J | m; //J与m按位或使F0对应低位为1
            if(F1) J=J | n; //J与n按位或使F1对应高位为1
        }
        if(I<J)
        {
            Temp=A[I];
            A[I] =A[J];
            A[J]=Temp;
        }                                
    }
}