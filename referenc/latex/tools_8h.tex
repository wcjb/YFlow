\hypertarget{tools_8h}{}\doxysection{C\+:/\+Users/wcjb/\+Documents/\+Code\+Space/\+YFlow/source/tools.h 文件参考}
\label{tools_8h}\index{C:/Users/wcjb/Documents/CodeSpace/YFlow/source/tools.h@{C:/Users/wcjb/Documents/CodeSpace/YFlow/source/tools.h}}
\doxysubsection*{函数}
\begin{DoxyCompactItemize}
\item 
int \mbox{\hyperlink{tools_8h_ac95c3156aa9bc02c8aa77d5faa7dd2ed}{sys}} (void)
\begin{DoxyCompactList}\small\item\em 判断当前系统类型 \end{DoxyCompactList}\item 
float \mbox{\hyperlink{tools_8h_a55a133284c9a7f0b98e5fc2af98a67e4}{Inv\+Sqrt}} (float x)
\begin{DoxyCompactList}\small\item\em 基于牛顿迭代的快速平方根倒数算法(x(n+1) = x(n)-\/f(x(n))/f\textquotesingle{}(x(n))) \end{DoxyCompactList}\item 
int \mbox{\hyperlink{tools_8h_a4ac7e00b51bccbeed77e44974947570d}{Is\+Big\+Endian}} ()
\begin{DoxyCompactList}\small\item\em 快速幂实现 \end{DoxyCompactList}\item 
\mbox{\Hypertarget{tools_8h_a4b37d08859ea92c14e686b5b7fa08bb3}\label{tools_8h_a4b37d08859ea92c14e686b5b7fa08bb3}} 
long long {\bfseries binpow} (long long a, long long b)
\item 
double \mbox{\hyperlink{tools_8h_af56fa6fd935f9e901926e738068f04ca}{\+\_\+\+\_\+ieee754\+\_\+log}} (double x)
\begin{DoxyCompactList}\small\item\em 基于泰勒级数和\+Remez算法的ln函数计算实现 \end{DoxyCompactList}\item 
double \mbox{\hyperlink{tools_8h_a299923f0ae7725b0cb3168d743fea53d}{\+\_\+\+\_\+simpson\+\_\+log}} (double x)
\begin{DoxyCompactList}\small\item\em 基于自适应辛普森的ln函数实现 \end{DoxyCompactList}\item 
double \mbox{\hyperlink{tools_8h_a2ecbbc8209107f108d54ed8730be5100}{log}} (double x, int n)
\begin{DoxyCompactList}\small\item\em 实现任意底数n的对数函数 由于计算机无法存储浮点数的精确值（浮点数的存储方法可以参考 IEEE 754，这里不再赘述）， 而指数函数和对数函数的参数和返回值均为浮点数，因此运算过程中会存在误差。 \end{DoxyCompactList}\item 
float \mbox{\hyperlink{tools_8h_ac9159739323a7ca5cab03be69aae1b74}{\+\_\+sqrt}} (float x)
\begin{DoxyCompactList}\small\item\em 平方根函数实现 \end{DoxyCompactList}\item 
void \mbox{\hyperlink{tools_8h_acd3415eef442ced2b5e064f95f04b624}{swap}} (int $\ast$x, int $\ast$y)
\begin{DoxyCompactList}\small\item\em 变量值交换 \end{DoxyCompactList}\item 
void \mbox{\hyperlink{tools_8h_ac6a79a9cb059f501247f6912aaa12198}{selection\+\_\+sort}} (int list\mbox{[}$\,$\mbox{]}, int n)
\begin{DoxyCompactList}\small\item\em 选择排序的\+C++实现,其原理为首先找出序列中的最小（最大）元素， 并置于序列的起始位置，再从剩下的元素中找到最小（最大元素）置于已排 序序列的末尾，以此类推，直到确定最后一个元素的位置，则此时所有元素 排序完成。算法的时间复杂度为\+O(n$^\wedge$2) \end{DoxyCompactList}\item 
void \mbox{\hyperlink{tools_8h_a0675fdf5a735134e050730db5dbea528}{bubble\+\_\+sort}} (int list\mbox{[}$\,$\mbox{]}, int n)
\begin{DoxyCompactList}\small\item\em 冒泡排序算法的\+C++实现，其原理为重复访问序列中的元素，比较 两个相邻元素的大小，如果顺序错误（此处的顺序错误指不符合理想顺序）， 则将它们的位置进调换，一直重复，直到没有元素需要进行位置交换为止。 冒泡排序名称的由来是因为较小的元素会慢慢‘浮’到序列的顶端。算法的 时间复杂度为\+O(n$^\wedge$2) \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{详细描述}
\begin{DoxyAuthor}{作者}
殉道者 (\href{mailto:wcjbyjx@gmail.com}{\texttt{ wcjbyjx@gmail.\+com}}) 
\end{DoxyAuthor}
\begin{DoxyVersion}{版本}
0.\+0.\+1 
\end{DoxyVersion}
\begin{DoxyDate}{日期}
2021-\/01-\/25 
\end{DoxyDate}
\begin{DoxyCopyright}{版权所有}
Copyright © 2014-\/2021 weichijunbo. 
\end{DoxyCopyright}
\begin{DoxySeeAlso}{参见}
\href{https://zhuanlan.zhihu.com/p/80458536}{\texttt{ math.\+h实现}} \DoxyHorRuler{0}
 
\end{DoxySeeAlso}
\begin{DoxyParagraph}{Change\+Log\+:}
\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{4}{|X[-1]}|}
\hline
\cellcolor{\tableheadbgcolor}\textbf{ Date }&\cellcolor{\tableheadbgcolor}\textbf{ Version }&\cellcolor{\tableheadbgcolor}\textbf{ Author }&\cellcolor{\tableheadbgcolor}\textbf{ Description }\\\cline{1-4}
\endfirsthead
\hline
\endfoot
\hline
\cellcolor{\tableheadbgcolor}\textbf{ Date }&\cellcolor{\tableheadbgcolor}\textbf{ Version }&\cellcolor{\tableheadbgcolor}\textbf{ Author }&\cellcolor{\tableheadbgcolor}\textbf{ Description }\\\cline{1-4}
\endhead
2021-\/01-\/25 &1.\+0 &殉道者 &内容 \\\cline{1-4}
\end{longtabu}
\DoxyHorRuler{0}
 
\end{DoxyParagraph}


\doxysubsection{函数说明}
\mbox{\Hypertarget{tools_8h_af56fa6fd935f9e901926e738068f04ca}\label{tools_8h_af56fa6fd935f9e901926e738068f04ca}} 
\index{tools.h@{tools.h}!\_\_ieee754\_log@{\_\_ieee754\_log}}
\index{\_\_ieee754\_log@{\_\_ieee754\_log}!tools.h@{tools.h}}
\doxysubsubsection{\texorpdfstring{\_\_ieee754\_log()}{\_\_ieee754\_log()}}
{\footnotesize\ttfamily double \+\_\+\+\_\+ieee754\+\_\+log (\begin{DoxyParamCaption}\item[{double}]{x }\end{DoxyParamCaption})}



基于泰勒级数和\+Remez算法的ln函数计算实现 


\begin{DoxyParams}{参数}
{\em x} & 要取自然对数的值 \\
\hline
\end{DoxyParams}
\begin{DoxyNote}{注解}
~\newline

\begin{DoxyEnumerate}
\item 参数约化（\+Argument Reduction）\+: 找到k和f使得 x = 2$^\wedge$k $\ast$ (1+f), 其中 sqrt(2)/2 \texorpdfstring{$<$}{<} 1+f \texorpdfstring{$<$}{<} sqrt(2) . 则有 log(x) = k$\ast$log2+log(1+f)
\item 计算log(1+f)的近似值. 作变换s = f/(2+f) ; 则有log(1+f) = log(1+s) -\/ log(1-\/s) = 2s + 2/3 s$\ast$$\ast$3 + 2/5 s$\ast$$\ast$5 + ... = 2s + s$\ast$R 接下来在区间\mbox{[}0,0.\+1716\mbox{]}使用\+Remez算法来计算多项式\+R的最佳一致逼近 多项式，理论上，度数为14的最佳一致逼近多项式的精度为2$\ast$$\ast$-\/58.45，完全能 满足64位浮点数的运算要求。 得到最佳一致多项式如下： R(z) $\sim$ Lg1$\ast$s +Lg2$\ast$s +Lg3$\ast$s +Lg4$\ast$s +Lg5$\ast$s +Lg6$\ast$s +Lg7$\ast$s ( Lg1 到 Lg7 的值已在程序种给出) 此时， \begin{DoxyVerb}| Lg1*s +...+Lg7*s    -  R(z) | <= 2**-58.45
\end{DoxyVerb}
 然后根据2s = f -\/ s$\ast$f = f -\/ hfsq + s$\ast$hfsq, 其中 hfsq = f$\ast$f/2. 得到 log(1+f) = f -\/ s$\ast$(f -\/ R) ~\newline
 如果对精度有更高要求，则继续迭代2s=f-\/sf,得到： log(1+f) = f -\/ (hfsq -\/ s$\ast$(hfsq+R)).
\end{DoxyEnumerate}
\end{DoxyNote}

\begin{DoxyEnumerate}
\item 最终, log(x) = k$\ast$ln2 + log(1+f). ~\newline
 = k$\ast$ln2\+\_\+hi+(f-\/(hfsq-\/(s$\ast$(hfsq+R)+k$\ast$ln2\+\_\+lo))) 需要注意的是，此处将ln2分成了两部分进行计算： ln2 = ln2\+\_\+hi + ln2\+\_\+lo 当$\vert$n$\vert$ \texorpdfstring{$<$}{<} 2000时n$\ast$ln2\+\_\+hi是精确的。
\end{DoxyEnumerate}

\begin{DoxyReturn}{返回}
float {\ttfamily @see}  参考知乎回答的第一条答案：https\+://www.zhihu.\+com/question/333371020/answer/1686069171 关于\+Remez算法可参看项目路径/docs下的\+Function approximation and the remez algorithm和数值计 算方法等文档。 算法实现可参考\+C语言math库源码http\+://www.netlib.\+org/fdlibm/。 
\end{DoxyReturn}
\mbox{\Hypertarget{tools_8h_a299923f0ae7725b0cb3168d743fea53d}\label{tools_8h_a299923f0ae7725b0cb3168d743fea53d}} 
\index{tools.h@{tools.h}!\_\_simpson\_log@{\_\_simpson\_log}}
\index{\_\_simpson\_log@{\_\_simpson\_log}!tools.h@{tools.h}}
\doxysubsubsection{\texorpdfstring{\_\_simpson\_log()}{\_\_simpson\_log()}}
{\footnotesize\ttfamily double \+\_\+\+\_\+simpson\+\_\+log (\begin{DoxyParamCaption}\item[{double}]{x }\end{DoxyParamCaption})}



基于自适应辛普森的ln函数实现 


\begin{DoxyParams}{参数}
{\em x} & desc \\
\hline
\end{DoxyParams}
\begin{DoxyNote}{注解}
ln(x)可表示为函数1/t在\mbox{[}1,x\mbox{]}上的积分变上限函数，再使用自适应辛普森公式计算该积分 即可得到函数值 
\end{DoxyNote}
\begin{DoxyReturn}{返回}
double {\ttfamily } 
\end{DoxyReturn}
\mbox{\Hypertarget{tools_8h_ac9159739323a7ca5cab03be69aae1b74}\label{tools_8h_ac9159739323a7ca5cab03be69aae1b74}} 
\index{tools.h@{tools.h}!\_sqrt@{\_sqrt}}
\index{\_sqrt@{\_sqrt}!tools.h@{tools.h}}
\doxysubsubsection{\texorpdfstring{\_sqrt()}{\_sqrt()}}
{\footnotesize\ttfamily float \+\_\+sqrt (\begin{DoxyParamCaption}\item[{float}]{x }\end{DoxyParamCaption})}



平方根函数实现 


\begin{DoxyParams}{参数}
{\em x} & desc \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
float {\ttfamily } 
\end{DoxyReturn}
\mbox{\Hypertarget{tools_8h_a0675fdf5a735134e050730db5dbea528}\label{tools_8h_a0675fdf5a735134e050730db5dbea528}} 
\index{tools.h@{tools.h}!bubble\_sort@{bubble\_sort}}
\index{bubble\_sort@{bubble\_sort}!tools.h@{tools.h}}
\doxysubsubsection{\texorpdfstring{bubble\_sort()}{bubble\_sort()}}
{\footnotesize\ttfamily void bubble\+\_\+sort (\begin{DoxyParamCaption}\item[{int}]{list\mbox{[}$\,$\mbox{]},  }\item[{int}]{n }\end{DoxyParamCaption})}



冒泡排序算法的\+C++实现，其原理为重复访问序列中的元素，比较 两个相邻元素的大小，如果顺序错误（此处的顺序错误指不符合理想顺序）， 则将它们的位置进调换，一直重复，直到没有元素需要进行位置交换为止。 冒泡排序名称的由来是因为较小的元素会慢慢‘浮’到序列的顶端。算法的 时间复杂度为\+O(n$^\wedge$2) 


\begin{DoxyParams}{参数}
{\em list} & desc \\
\hline
{\em n} & desc \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{tools_8h_a55a133284c9a7f0b98e5fc2af98a67e4}\label{tools_8h_a55a133284c9a7f0b98e5fc2af98a67e4}} 
\index{tools.h@{tools.h}!InvSqrt@{InvSqrt}}
\index{InvSqrt@{InvSqrt}!tools.h@{tools.h}}
\doxysubsubsection{\texorpdfstring{InvSqrt()}{InvSqrt()}}
{\footnotesize\ttfamily float Inv\+Sqrt (\begin{DoxyParamCaption}\item[{float}]{x }\end{DoxyParamCaption})}



基于牛顿迭代的快速平方根倒数算法(x(n+1) = x(n)-\/f(x(n))/f\textquotesingle{}(x(n))) 


\begin{DoxyParams}{参数}
{\em x} & 需要进行平方倒数运算的数\\
\hline
\end{DoxyParams}
x = 0.\+5$\ast$x(3-\/2$\ast$alpha$\ast$x$\ast$) \begin{DoxyReturn}{返回}
计算结果 
\end{DoxyReturn}
\mbox{\Hypertarget{tools_8h_a4ac7e00b51bccbeed77e44974947570d}\label{tools_8h_a4ac7e00b51bccbeed77e44974947570d}} 
\index{tools.h@{tools.h}!IsBigEndian@{IsBigEndian}}
\index{IsBigEndian@{IsBigEndian}!tools.h@{tools.h}}
\doxysubsubsection{\texorpdfstring{IsBigEndian()}{IsBigEndian()}}
{\footnotesize\ttfamily int Is\+Big\+Endian (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



快速幂实现 

其本质思想是将取幂的任务按照指数的二进制表示 来分割成更小的任务，即将指数不停的二分。 \hypertarget{tools_8h_算法描述}{}\doxysubsection{算法描述}\label{tools_8h_算法描述}

\begin{DoxyEnumerate}
\item 若指数b为偶数，则f = a$^\wedge$b = a$^\wedge$(b/2)$\ast$a$^\wedge$(b/2)
\item 若指数b为奇数，则f = a$^\wedge$b = a$^\wedge$\mbox{[}(b-\/1)/2\mbox{]}$\ast$a$^\wedge$\mbox{[}(b-\/1)/2\mbox{]}$\ast$b
\item 经过上述转换将a$^\wedge$b的计算问题转为a$^\wedge$(b/2)或a$^\wedge$\mbox{[}(b-\/1)/2\mbox{]}的计算 问题，继续上述迭代过程，直到指数为1为止；如此将计算的时间复杂度 从\+O(n)降为log(n); 
\begin{DoxyParams}{参数}
{\em a} & 幂运算的底数 \\
\hline
{\em b} & 幂运算的指数 \\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{参见}
快速幂 \href{https://oi-wiki.org/math/quick-pow/}{\texttt{ https\+://oi-\/wiki.\+org/math/quick-\/pow/}} 
\end{DoxySeeAlso}
\begin{DoxyReturn}{返回}
long long {\ttfamily } 
\end{DoxyReturn}
判断当前计算设备是大端存储还是小端存储 \begin{DoxyReturn}{返回}
int {\ttfamily 若为大端存储返回1，小端存储返回0} 
\end{DoxyReturn}

\end{DoxyEnumerate}\mbox{\Hypertarget{tools_8h_a2ecbbc8209107f108d54ed8730be5100}\label{tools_8h_a2ecbbc8209107f108d54ed8730be5100}} 
\index{tools.h@{tools.h}!log@{log}}
\index{log@{log}!tools.h@{tools.h}}
\doxysubsubsection{\texorpdfstring{log()}{log()}}
{\footnotesize\ttfamily double log (\begin{DoxyParamCaption}\item[{double}]{x,  }\item[{int}]{n }\end{DoxyParamCaption})}



实现任意底数n的对数函数 由于计算机无法存储浮点数的精确值（浮点数的存储方法可以参考 IEEE 754，这里不再赘述）， 而指数函数和对数函数的参数和返回值均为浮点数，因此运算过程中会存在误差。 

\begin{DoxyNote}{注解}
log\+\_\+\{n\}(x) = ln(x)/ln(n) 
\end{DoxyNote}

\begin{DoxyParams}{参数}
{\em x} & 要求对数的对象 \\
\hline
{\em n} & 对数的底数 \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
double {\ttfamily } 
\end{DoxyReturn}
\mbox{\Hypertarget{tools_8h_ac6a79a9cb059f501247f6912aaa12198}\label{tools_8h_ac6a79a9cb059f501247f6912aaa12198}} 
\index{tools.h@{tools.h}!selection\_sort@{selection\_sort}}
\index{selection\_sort@{selection\_sort}!tools.h@{tools.h}}
\doxysubsubsection{\texorpdfstring{selection\_sort()}{selection\_sort()}}
{\footnotesize\ttfamily void selection\+\_\+sort (\begin{DoxyParamCaption}\item[{int}]{list\mbox{[}$\,$\mbox{]},  }\item[{int}]{n }\end{DoxyParamCaption})}



选择排序的\+C++实现,其原理为首先找出序列中的最小（最大）元素， 并置于序列的起始位置，再从剩下的元素中找到最小（最大元素）置于已排 序序列的末尾，以此类推，直到确定最后一个元素的位置，则此时所有元素 排序完成。算法的时间复杂度为\+O(n$^\wedge$2) 


\begin{DoxyParams}{参数}
{\em list} & desc \\
\hline
{\em n} & desc \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{tools_8h_acd3415eef442ced2b5e064f95f04b624}\label{tools_8h_acd3415eef442ced2b5e064f95f04b624}} 
\index{tools.h@{tools.h}!swap@{swap}}
\index{swap@{swap}!tools.h@{tools.h}}
\doxysubsubsection{\texorpdfstring{swap()}{swap()}}
{\footnotesize\ttfamily void swap (\begin{DoxyParamCaption}\item[{int $\ast$}]{x,  }\item[{int $\ast$}]{y }\end{DoxyParamCaption})}



变量值交换 


\begin{DoxyParams}{参数}
{\em x} & desc \\
\hline
{\em y} & desc \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{tools_8h_ac95c3156aa9bc02c8aa77d5faa7dd2ed}\label{tools_8h_ac95c3156aa9bc02c8aa77d5faa7dd2ed}} 
\index{tools.h@{tools.h}!sys@{sys}}
\index{sys@{sys}!tools.h@{tools.h}}
\doxysubsubsection{\texorpdfstring{sys()}{sys()}}
{\footnotesize\ttfamily int sys (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



判断当前系统类型 

\begin{DoxyReturn}{返回}
int {\ttfamily 0为windows},1为macos 
\end{DoxyReturn}
